#!/usr/bin/env node
// Based on https://github.com/dcodeIO/protobuf.js/blob/6.8.6/cli/targets/static.js
//
// Original work Copyright (c) 2016, Daniel Wirtz  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
// * Neither the name of its author, nor the names of its contributors
//   may be used to endorse or promote products derived from this software
//   without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---
//
// Code generated by the command line utilities is owned by the owner
// of the input file used when generating it. This code is not
// standalone and requires a support library to be linked with it. This
// support library is itself covered by the above license.
//
// https://github.com/dcodeIO/protobuf.js/blob/6.8.6/cli/LICENSE
//
// ---
//
// Modified work Copyright (c) 2018 MyGnar, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

'use strict';

const version = '0.0.5'

const program = require('commander')
const protobuf = require('protobufjs')
const fs = require('fs')
const path = require('path')

const
	Type      = protobuf.Type,
	Service   = protobuf.Service,
	Method    = protobuf.Method,
	Enum      = protobuf.Enum,
	Namespace = protobuf.Namespace,
	util      = protobuf.util

let protos = []
program
	.version(version, '-v, --version')
	.usage('[-j] [-r] <protofile ...>')
	.option('-j, --java [src_dir]', 'Generate code for java client')
	.option('-r, --react_native', 'Generate code for react-native android module')
	// .option('-s, --swift', 'Generate code for swift client')
	.arguments('<protofiles...>')
	.action(protofiles => { protos = protofiles })
	.parse(process.argv)

const
	root = new protobuf.Root().loadSync(protos, { keepCase: true }).resolveAll(),
	protoNames = protos.map(pp => pp.replace(/.*\//, '')).join(', ')
let out = []

let indent = 0
const codeLine = line => {
	if (line === '') { return out.push('') }
	let ind = ''
	for (let i = 0; i < indent; ++i) { ind += "\t" }
	return out.push(ind + line)
}

const codeComment = lines => {
	const split = []
	for (let i = 0; i < lines.length; ++i) {
		if (lines[i] === null) { continue }
		Array.prototype.push.apply(split, lines[i].split(/\r?\n/g))
	}
	codeLine('/**')
	split.forEach(line => {
		if (line === null) return
		codeLine(' * ' + line.replace(/\*\//g, '* /'))
	})
	codeLine(' */')
}

const mkdirSync = dirPath => {
	try {
		fs.mkdirSync(path.resolve(dirPath))
	} catch (err) {
		if (err.code !== 'EEXIST') throw err
	}
}
const mkdirpSync = dirPath => {
	const parts = dirPath.split(path.sep)
	for (let ii = 1; ii <= parts.length; ii++) {
		mkdirSync(path.join.apply(null, parts.slice(0, ii)))
	}
}

const L = codeLine
const C = codeComment
const generatedBy = () => {
	L(`// Code generated by gen_twirpjs v${version}, DO NOT EDIT.`)
	L(`// source: ${protoNames}`)
}

/**
 * Begin code generation
 */

//
// Generate JS client
//
codeLine(`// Code generated by gen_twirpjs v${version}, DO NOT EDIT.`)
codeLine(`// source: ${protos.join(', ')}`)
codeLine(`import newTwirpClient from 'twirpjs'`)

// Import pb.js files
for (const nn of root.nestedArray) {
	if (!(nn instanceof Namespace)) { continue }
	codeLine(`import { ${nn.name} } from './${nn.name}.pb'`)
}
codeLine(``)

// Create a new-client function for each service
for (const n of root.nestedArray) {
	const nn = n.name
	for (const s of n.nestedArray) {
		if (!(s instanceof Service)) { continue }
		const ss = s.name
		const streamers = []
		for (const mm in s.methods) {
			const m = s.methods[mm]
			if (m && m.responseStream) {
				streamers.push(mm)
			}
		}
		codeComment([
			`Create a new ${nn}.${ss} client`,
		])
		const Ss = ss.replace(/^\w/, c => c.toUpperCase()) // uppercase first letter of service name for new client func
		codeLine(`export function new${Ss}Client(hostURL, opts = {}) {`)
			++indent
			codeLine(`return newTwirpClient(hostURL, {`)
				++indent
				codeLine(`serviceRoute: '${nn}.${ss}',`)
				codeLine(`serviceClass: ${nn}.${ss},`)
				codeLine(`streamingRespMethods: ${streamers.length > 0 ? JSON.stringify(streamers) : 'null'},`)
				codeLine(`...opts`)
				--indent
			codeLine(`})`)
			--indent
		codeLine(`}`)
		codeLine(``)
	}
}

// Output the generated code to stdout
console.log(out.join("\n"))
